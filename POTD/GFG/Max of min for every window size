class Solution {
  public:
    vector<int> maxOfMins(vector<int>& arr) {
        //  code here
        
        // queue<int>st;
        
        // for(int i=2;i<n;i++);
        // {   
        //     int st=0;
        //     int end=1;
        //     st.push(arr[st]);
        //     while(st<end)
        //     {
        //         if(!st.empty())
        //         {
        //             st.push(arr[end]);
        //             end++;
        //         }
        //         else
        //         {
        //             if(end-st+1<i)
        //             {
        //                 if(arr[end]<st.top())
        //                 {
        //                     while(!st.empty())
        //                     {
        //                         st.pop();
        //                     }
                        
        //                 st.push(arr[end]);
        //                 }
        //                 end++;
        //             }
        //             else if((end-st+1)==i)
        //             {
        //                 if(arr[end]<st.top())
        //                 {
        //                      while(!st.empty())
        //                     {
        //                         st.pop();
        //                     }
                        
        //                 st.push(arr[end]);
        //                 }
        //                 ans.push_back(st.top());
        //                 if(arr[st]==st.top())
        //                 {
        //                     st.pop();
        //                     if(st.empty())
        //                     st.push(arr[end]);
        //                 }
        //                 st++;
        //                 end++;
        //             }
        //         }
        //     }
        //     int mn=*min_element(arr.begin(),arr.end());
        //     ans.push_back(mn);
        //     return ans;
        
        
        
        
    //   int n = arr.size();
    //     vector<int> ans;


    //     for (int w = 1; w <= n; w++) {
    //         vector<int> res;

  
    //         priority_queue<pair<int,int>, vector<pair<int,int>>, greater<pair<int,int>>> pq;

    //         int st = 0, e = 0;

      
    //         while (e < w) {
    //             pq.push({arr[e], e});
    //             e++;
    //         }

         
    //         while (e <= n) {
    
    //             while (!pq.empty() && pq.top().second < st) {
    //                 pq.pop();
    //             }

              
    //             res.push_back(pq.top().first);

              
    //             if (e < n) {
    //                 pq.push({arr[e], e});
    //             }
    //             st++;
    //             e++;
    //         }

           
    //         int best = *max_element(res.begin(), res.end());
    //         ans.push_back(best);
    //     }

    //     return ans;
    
        int n = arr.size();

        vector<int> left(n), right(n);

        // Step 1: Find previous smaller element for each
        stack<int> st;
        for (int i = 0; i < n; i++) {
            while (!st.empty() && arr[st.top()] >= arr[i]) {
                st.pop();
            }
            left[i] = st.empty() ? -1 : st.top();
            st.push(i);
        }

        // Step 2: Find next smaller element for each
        while (!st.empty()) st.pop();
        for (int i = n - 1; i >= 0; i--) {
            while (!st.empty() && arr[st.top()] >= arr[i]) {
                st.pop();
            }
            right[i] = st.empty() ? n : st.top();
            st.push(i);
        }

        // Step 3: For each element, find window size
        vector<int> ans(n + 1, INT_MIN);
        for (int i = 0; i < n; i++) {
            int len = right[i] - left[i] - 1;
            ans[len] = max(ans[len], arr[i]);
        }

        // Step 4: Fill remaining values
        for (int i = n - 1; i >= 1; i--) {
            ans[i] = max(ans[i], ans[i + 1]);
        }

        // Step 5: Discard ans[0] and return result
        vector<int> res(ans.begin() + 1, ans.end());
        return res;
    }
};
