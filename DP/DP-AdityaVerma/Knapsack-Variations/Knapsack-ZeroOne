class Solution
{
public:
    int help(int n, int w, vector<int> &val, vector<int> &wt, vector<vector<int>> &t)
    {
        if (n == 0 || w == 0)
            return 0;

        if (t[n][w] != -1)
            return t[n][w];

        if (wt[n - 1] <= w)
        {
            return t[n][w] = max(
                       val[n - 1] + help(n - 1, w - wt[n - 1], val, wt, t),
                       help(n - 1, w, val, wt, t));
        }
        else
        {
            return t[n][w] = help(n - 1, w, val, wt, t);
        }
    }

    int knapsack(int W, vector<int> &val, vector<int> &wt)
    {
        int n = wt.size();
        vector<vector<int>> t(n + 1, vector<int>(W + 1, -1));
        return help(n, W, val, wt, t);
    }
};

The above is Memoized version;





The tabulation version is :

    int
    main(int W, vector<int> &val, vector<int> &wt)
{
    int n = wt.size();

    vector<vector<int>> dp(n + 1, vector<int>(W + 1));

    for (int i = 0; i <= n; i++)
    {
        for (int j = 0; j <= W; j++)
        {
            if (i == 0 j == 0)
                dp[i][j] = 0;
        }
    }

    for (int i = 1; i <= n; i++)
    {
        for (int j = 0; j <= W; j++)
        {
            if (wt[i - 1] <= j)
                dp[i][j] = max(val[i - 1] + dp[i - 1][j - wt[i - 1]], dp[i - 1][j]);
            else
                dp[i][j] = dp[i - 1][j];
        }
    }

    return dp[n][W];
}